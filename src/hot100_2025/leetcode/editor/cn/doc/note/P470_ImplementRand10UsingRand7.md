# 用 Rand7() 实现 Rand10() 解题详解

## 解题思路

**总思路**：使用拒绝采样方法，通过两次 Rand7() 调用生成均匀分布的 1-10 随机数。

**分步骤**：
1. 使用两次 Rand7() 生成 1-49 的均匀随机数
2. 只接受 1-40 的结果，拒绝 41-49
3. 将 1-40 映射到 1-10：(num - 1) % 10 + 1
4. 如果被拒绝，重新采样

## 归类说明
- **主要归类**：概率、拒绝采样
- **算法技巧**：均匀分布、概率计算
- **相关题型**：用 Rand5() 实现 Rand7()、随机数生成

## Java代码实现

```java
/**
 * The rand7() API is already defined in the parent class SolBase.
 * public int rand7();
 * @return a random integer in the range 1 to 7
 */
class Solution extends SolBase {
    /**
     * 拒绝采样解法
     * @return 1到10的均匀随机整数
     */
    public int rand10() {
        int num;
        do {
            // 生成1-49的均匀随机数
            num = (rand7() - 1) * 7 + rand7();
        } while (num > 40); // 拒绝41-49，只接受1-40
        
        // 将1-40映射到1-10
        return (num - 1) % 10 + 1;
    }
    
    /**
     * 优化版本：减少期望调用次数
     */
    public int rand10Optimized() {
        while (true) {
            int num = (rand7() - 1) * 7 + rand7(); // 1-49
            if (num <= 40) {
                return (num - 1) % 10 + 1;
            }
            
            // 利用被拒绝的41-49，生成1-63
            num = (num - 41) * 7 + rand7(); // 1-63
            if (num <= 60) {
                return (num - 1) % 10 + 1;
            }
            
            // 利用被拒绝的61-63，生成1-21
            num = (num - 61) * 7 + rand7(); // 1-21
            if (num <= 20) {
                return (num - 1) % 10 + 1;
            }
            // 如果还是大于20，继续循环
        }
    }
    
    /**
     * 另一种思路：独立生成个位和十位
     */
    public int rand10Alternative() {
        int row, col, idx;
        do {
            row = rand7();
            col = rand7();
            idx = (row - 1) * 7 + col; // 1-49
        } while (idx > 40);
        
        return 1 + (idx - 1) % 10;
    }
}
```

## 关键点解析

### 核心数学原理

1. **生成 1-49 的均匀分布**：
   ```java
   num = (rand7() - 1) * 7 + rand7();
   ```
    - 第一个 rand7() 决定"十位"：(0,7,14,21,28,35,42)
    - 第二个 rand7() 决定"个位"：1-7
    - 组合得到：1-49 的均匀分布

2. **拒绝采样原理**：
    - 只接受 1-40（40是10的倍数）
    - 拒绝 41-49，重新采样
    - 保证 1-10 每个数字概率相等

3. **映射到 1-10**：
   ```java
   return (num - 1) % 10 + 1;
   ```
    - 1→1, 2→2, ..., 10→10
    - 11→1, 12→2, ..., 20→10
    - 以此类推

### 执行过程示例

```
第一次采样:
rand7() = 3, rand7() = 5
num = (3-1)*7 + 5 = 2*7 + 5 = 19
19 <= 40 → 接受
结果 = (19-1)%10 + 1 = 18%10 + 1 = 8 + 1 = 9

第二次采样:
rand7() = 6, rand7() = 7  
num = (6-1)*7 + 7 = 5*7 + 7 = 42
42 > 40 → 拒绝，重新采样

第三次采样:
rand7() = 2, rand7() = 3
num = (2-1)*7 + 3 = 1*7 + 3 = 10
10 <= 40 → 接受
结果 = (10-1)%10 + 1 = 9%10 + 1 = 9 + 1 = 10
```

### 概率分析

**基础版本**：
- 每次采样接受概率：40/49 ≈ 81.63%
- 期望调用次数：2 × (49/40) = 2.45 次 rand7()

**优化版本**：
- 第一次接受概率：40/49
- 第二次接受概率：(9/49) × (60/63)
- 第三次接受概率：(9/49) × (3/63) × (20/21)
- 期望调用次数更低

## 学习建议

1. **理解均匀分布**：
    - 掌握如何组合多个均匀分布得到更大的均匀分布
    - 理解拒绝采样的原理

2. **掌握数学推导**：
    - 理解为什么 (a-1)*b + c 能生成均匀分布
    - 理解模运算的映射原理

3. **处理边界情况**：
    - 确保概率完全相等
    - 避免无限循环（理论上不会，但要注意实现）

4. **相关题目练习**：
    - 用 Rand5() 实现 Rand7()
    - 随机数索引
    - 按权重随机选择

5. **复杂度分析**：
    - 时间复杂度：期望 O(1)，最坏 O(∞)（理论上）
    - 空间复杂度：O(1)

6. **调试技巧**：
    - 统计大量调用的分布情况
    - 验证每个数字出现概率是否相等
    - 测试期望调用次数

7. **算法选择**：
    - 面试推荐基础版本
    - 实际应用推荐优化版本
    - 理解原理后再尝试其他变种

## 为什么这样设计？

### 1. **为什么是 7×7=49？**
- 需要找到大于10的倍数
- 49是大于40的最小7的倍数
- 40是10的倍数，保证均匀分布

### 2. **为什么拒绝 41-49？**
- 如果使用 41-49，无法均匀映射到 1-10
- 49 ÷ 10 = 4余9，会导致1-9出现5次，10出现4次

### 3. **优化版本的优势**
```java
// 基础版本：可能多次拒绝
do {
    num = (rand7()-1)*7 + rand7();
} while (num > 40);

// 优化版本：利用被拒绝的样本
if (num <= 40) {
    // 使用
} else if (num <= 60) {
    // 利用被拒绝的样本
} else if (num <= 20) {
    // 再次利用
}
```

## 常见问题

**Q: 为什么不用 (rand7() + rand7()) % 10 + 1？**
A: 这样不是均匀分布，两个骰子求和的分布是中间高两边低。

**Q: 期望调用次数怎么计算？**
A: 每次采样需要2次rand7()，接受概率p=40/49，期望采样次数=1/p，所以期望调用次数=2/p=2×49/40=2.45。

**Q: 会不会无限循环？**
A: 理论上不会，因为每次都有正概率接受。实际中几乎不会出现长时间拒绝。

这道题很好地训练了概率思维和拒绝采样技巧，掌握它对解决其他随机数问题很有帮助！