# 516. 最长回文子序列

## 📝 解题思路（总分结构）

### 总思路
使用动态规划，定义 `dp[i][j]` 表示字符串 `s` 在区间 `[i, j]` 内的最长回文子序列长度。

### 分步骤详解
1. **定义状态**：`dp[i][j]` 表示子串 `s[i..j]` 的最长回文子序列长度
2. **初始化**：单个字符的回文子序列长度为1
3. **状态转移**：
    - 如果 `s[i] == s[j]`，则 `dp[i][j] = dp[i+1][j-1] + 2`
    - 如果 `s[i] != s[j]`，则 `dp[i][j] = max(dp[i+1][j], dp[i][j-1])`
4. **遍历顺序**：从后往前遍历，因为需要用到后面的状态
5. **返回结果**：`dp[0][n-1]` 即为整个字符串的最长回文子序列长度

## 🏷️ 算法归类

**主要归类**：动态规划、字符串处理  
**相关知识点**：回文序列、区间DP、状态转移  
**难度级别**：中等  
**相似题型**：最长回文子串、回文子串、最长公共子序列

## 💻 Java代码实现

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        
        // 步骤1：创建dp数组，dp[i][j]表示子串s[i..j]的最长回文子序列长度
        int[][] dp = new int[n][n];
        
        // 步骤2：初始化对角线，单个字符的回文子序列长度为1
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }
        
        // 步骤3：从后往前遍历，因为需要用到后面的状态
        // i从最后一个字符开始往前遍历
        for (int i = n - 1; i >= 0; i--) {
            // j从i+1开始往后遍历，确保i < j
            for (int j = i + 1; j < n; j++) {
                // 步骤4：状态转移
                if (s.charAt(i) == s.charAt(j)) {
                    // 情况1：首尾字符相等
                    // 最长回文子序列 = 中间部分的最长回文子序列 + 2（首尾两个字符）
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    // 情况2：首尾字符不相等
                    // 最长回文子序列 = 要么去掉首字符，要么去掉尾字符，取最大值
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        
        // 步骤5：返回整个字符串的最长回文子序列长度
        return dp[0][n - 1];
    }
}
```

## 📚 学习建议

### 1. 理解动态规划的核心思想

**状态定义的理解**：
```java
// dp[i][j] 表示子串 s[i..j] 的最长回文子序列长度
// 注意：这里是子序列，不是子串（可以不连续）
```

**两种情况的直观理解**：

**情况1：`s[i] == s[j]`**
```
字符串: "bbbab"
考虑子串 "bbb":
i=0: 'b', j=2: 'b' 相等
dp[0][2] = dp[1][1] + 2 = 1 + 2 = 3
```

**情况2：`s[i] != s[j]`**
```
字符串: "bbbab"  
考虑子串 "bbba":
i=0: 'b', j=3: 'a' 不相等
dp[0][3] = max(dp[1][3], dp[0][2]) = max(2, 3) = 3
```

### 2. 算法过程可视化

**示例**：`s = "bbbab"`

**DP表填充过程**：
```
初始状态：
   b b b a b
b  1 0 0 0 0
b    1 0 0 0  
b      1 0 0
a        1 0
b          1

最终状态：
   b b b a b
b  1 2 3 3 4
b    1 2 2 3  
b      1 1 3
a        1 1
b          1

最长回文子序列长度 = 4 ("bbbb")
```

### 3. 复杂度分析
- **时间复杂度**：O(n²) - 需要填充 n×n 的DP表
- **空间复杂度**：O(n²) - DP表的大小

### 4. 空间优化版本

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        // 使用一维数组优化空间
        int[] dp = new int[n];
        
        for (int i = n - 1; i >= 0; i--) {
            dp[i] = 1;  // 单个字符的回文长度为1
            int prev = 0;  // 保存dp[i+1][j-1]的值
            
            for (int j = i + 1; j < n; j++) {
                int temp = dp[j];  // 保存当前dp[j]的值
                
                if (s.charAt(i) == s.charAt(j)) {
                    dp[j] = prev + 2;
                } else {
                    dp[j] = Math.max(dp[j], dp[j - 1]);
                }
                
                prev = temp;  // 更新prev为下一轮做准备
            }
        }
        
        return dp[n - 1];
    }
}
```

### 5. 学习路径建议

1. **先理解基础DP解法**：掌握状态定义和转移方程
2. **理解遍历顺序**：明白为什么要从后往前遍历
3. **手动模拟过程**：用具体例子填充DP表
4. **学习空间优化**：掌握一维DP的优化技巧
5. **练习相似题目**：
    - 5. 最长回文子串
    - 647. 回文子串
    - 1143. 最长公共子序列

### 6. 关键技巧详解

**遍历顺序的重要性**：
```java
// 必须从后往前遍历，因为dp[i][j]依赖于dp[i+1][j-1]
for (int i = n - 1; i >= 0; i--) {
    for (int j = i + 1; j < n; j++) {
        // 此时dp[i+1][j-1]已经计算过了
    }
}
```

**状态转移的直观理解**：
```java
if (s.charAt(i) == s.charAt(j)) {
    // 首尾相同，可以同时纳入回文序列
    dp[i][j] = dp[i+1][j-1] + 2;
} else {
    // 首尾不同，只能选择一边
    dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);
}
```

### 7. 调试技巧

**添加调试信息**：
```java
public int longestPalindromeSubseq(String s) {
    int n = s.length();
    int[][] dp = new int[n][n];
    
    for (int i = 0; i < n; i++) dp[i][i] = 1;
    
    for (int i = n - 1; i >= 0; i--) {
        for (int j = i + 1; j < n; j++) {
            System.out.printf("计算dp[%d][%d]: s[%d]='%c', s[%d]='%c'", 
                i, j, i, s.charAt(i), j, s.charAt(j));
            
            if (s.charAt(i) == s.charAt(j)) {
                dp[i][j] = dp[i+1][j-1] + 2;
                System.out.printf(" → 相等，dp[%d][%d]=%d+2=%d\n", 
                    i+1, j-1, dp[i+1][j-1], dp[i][j]);
            } else {
                dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);
                System.out.printf(" → 不相等，max(dp[%d][%d]=%d, dp[%d][%d]=%d)=%d\n", 
                    i+1, j, dp[i+1][j], i, j-1, dp[i][j-1], dp[i][j]);
            }
        }
    }
    
    return dp[0][n-1];
}
```

### 8. 常见错误避免

```java
// 错误：遍历顺序错误
for (int i = 0; i < n; i++) {  // 应该从后往前
    for (int j = i + 1; j < n; j++) {
        // 此时dp[i+1][j-1]可能还没计算
    }
}

// 错误：边界条件处理不当
// 必须初始化dp[i][i] = 1

// 错误：状态转移方程写反
dp[i][j] = dp[i-1][j+1] + 2;  // 应该是dp[i+1][j-1]
```

### 9. 实际应用场景
- DNA序列分析
- 文本压缩算法
- 数据验证和恢复
- 模式识别

## 🎯 核心思想总结

**最长回文子序列问题的精髓**：

### 1. 问题转化
将寻找最长回文子序列转化为**区间动态规划问题**

### 2. 状态设计
`dp[i][j]` 表示子串 `s[i..j]` 的最长回文子序列长度

### 3. 状态转移
- **首尾相同**：可以同时纳入回文序列
- **首尾不同**：选择去掉首或尾的较优解

### 4. 遍历策略
从后往前遍历，确保子问题先于原问题解决

## 💡 与最长回文子串的区别

| 方面 | 最长回文子序列 | 最长回文子串 |
|------|----------------|--------------|
| **连续性** | 可以不连续 | 必须连续 |
| **DP定义** | `dp[i][j]` 表示子序列长度 | `dp[i][j]` 表示是否为回文 |
| **状态转移** | 更复杂 | 相对简单 |
| **应用场景** | 更广泛 | 特定场景 |

**重要提示**：这道题是动态规划的经典应用，理解后可以解决许多类似的序列问题。建议多练习几个变种题目来加深理解！

通过这道题，你将深入掌握区间动态规划的应用，这是解决许多复杂序列问题的基础技能！