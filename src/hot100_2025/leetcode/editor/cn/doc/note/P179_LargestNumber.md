# 179. 最大数

## 📝 解题思路（总分结构）

### 总思路
将数字转换为字符串，然后自定义排序规则：比较两个字符串的不同拼接方式，选择能形成更大数字的排列顺序。

### 分步骤详解
1. **转换为字符串数组**：将整数数组转换为字符串数组便于比较
2. **自定义排序**：定义比较器，比较两个字符串的不同拼接结果
3. **排序数组**：按照自定义规则对字符串数组进行排序
4. **处理前导零**：如果排序后第一个元素是"0"，直接返回"0"
5. **拼接结果**：将排序后的字符串数组拼接成最终结果

## 🏷️ 算法归类

**主要归类**：排序、字符串处理、贪心算法  
**相关知识点**：自定义比较器、字符串拼接、数字比较  
**难度级别**：中等  
**相似题型**：重新排列数组的最大值、把数组排成最小的数

## 💻 Java代码实现

```java
import java.util.Arrays;

class Solution {
    public String largestNumber(int[] nums) {
        // 步骤1：将整数数组转换为字符串数组
        String[] strNums = new String[nums.length];
        for (int i = 0; i < nums.length; i++) {
            strNums[i] = String.valueOf(nums[i]);
        }
        
        // 步骤2：自定义排序规则
        // 比较两个字符串s1和s2，比较s1+s2和s2+s1哪个更大
        Arrays.sort(strNums, (a, b) -> {
            String order1 = a + b;  // a在前b在后的组合
            String order2 = b + a;  // b在前a在后的组合
            
            // 比较两种组合方式，返回更大的那种顺序
            // 使用compareTo方法，如果order2比order1大，返回正数，这样a会排在后面
            return order2.compareTo(order1);
        });
        
        // 步骤3：处理特殊情况 - 如果最大的数字是0，那么结果应该是"0"而不是"00...0"
        if (strNums[0].equals("0")) {
            return "0";
        }
        
        // 步骤4：将排序后的字符串数组拼接成最终结果
        StringBuilder result = new StringBuilder();
        for (String str : strNums) {
            result.append(str);
        }
        
        return result.toString();
    }
}
```

## 📚 学习建议

### 1. 理解核心比较逻辑

**关键比较规则**：
```java
// 比较 a+b 和 b+a 哪个更大
String order1 = a + b;  // 比如 "3" + "30" = "330"
String order2 = b + a;  // 比如 "30" + "3" = "303"

// 因为 "330" > "303"，所以 "3" 应该排在 "30" 前面
return order2.compareTo(order1);  // 返回负数，表示a应该排在b前面
```

**为什么这样比较？**
- 我们要找的是拼接后的最大数字
- 直接比较数字大小不行（比如3和30，3<30但330>303）
- 所以比较它们的两种拼接方式，选择更大的那种

### 2. 算法过程可视化

**示例**：`nums = [3, 30, 34, 5, 9]`

**排序过程**：
```
比较 "3" 和 "30":
  "3" + "30" = "330"
  "30" + "3" = "303"
  因为 "330" > "303"，所以 "3" 排在 "30" 前面

比较 "34" 和 "3":
  "34" + "3" = "343"  
  "3" + "34" = "334"
  因为 "343" > "334"，所以 "34" 排在 "3" 前面

比较 "9" 和 "34":
  "9" + "34" = "934"
  "34" + "9" = "349"
  因为 "934" > "349"，所以 "9" 排在 "34" 前面

最终排序：["9", "5", "34", "3", "30"]
拼接结果："9534330"
```

### 3. 复杂度分析
- **时间复杂度**：O(n log n) - 排序的时间复杂度
- **空间复杂度**：O(n) - 字符串数组的空间

### 4. 深入理解比较器

**比较器的返回值含义**：
```java
// 在Java的Arrays.sort中：
// 返回负数：第一个参数排在第二个参数前面
// 返回正数：第一个参数排在第二个参数后面  
// 返回0：两者相等

// 我们的比较器：(a, b) -> (b + a).compareTo(a + b)

// 如果 (b + a) > (a + b)，返回正数 → a排在b后面（我们想要b在前）
// 如果 (b + a) < (a + b)，返回负数 → a排在b前面（我们想要a在前）
// 这正好符合我们的需求！
```

### 5. 边界情况处理

**前导零的处理**：
```java
// 如果数组是[0, 0, 0]，排序后是["0", "0", "0"]
// 拼接结果是"000"，但应该返回"0"
if (strNums[0].equals("0")) {
    return "0";
}
```

### 6. 学习路径建议

1. **理解比较逻辑**：这是算法的核心
2. **掌握字符串比较**：理解 `String.compareTo()` 方法
3. **练习相似题目**：
    - 剑指 Offer 45. 把数组排成最小的数
    - 重新排列数组的最大值
4. **手动模拟过程**：用具体例子验证比较规则

### 7. 调试技巧

**添加调试信息**：
```java
public String largestNumber(int[] nums) {
    String[] strNums = new String[nums.length];
    for (int i = 0; i < nums.length; i++) {
        strNums[i] = String.valueOf(nums[i]);
    }
    
    Arrays.sort(strNums, (a, b) -> {
        String order1 = a + b;
        String order2 = b + a;
        int result = order2.compareTo(order1);
        
        System.out.println("比较: " + a + " 和 " + b);
        System.out.println("  " + order1 + " vs " + order2 + " = " + result);
        
        return result;
    });
    
    // ... 其余代码
}
```

### 8. 常见错误避免

```java
// 错误：直接按字符串字典序排序
Arrays.sort(strNums, (a, b) -> b.compareTo(a));
// 这样会得到 ["9", "5", "34", "30", "3"] = "9534303" 不是最大

// 错误：忘记处理前导零
// 如果输入[0,0]，会返回"00"而不是"0"

// 错误：比较器逻辑写反
return order1.compareTo(order2);  // 这样会得到最小数
```

### 9. 实际应用场景
- 电商商品价格排序显示
- 身份证号码、电话号码的特定排序
- 文件版本号的比较和排序
- 数据库查询结果的特定排序需求

## 🎯 核心思想总结

**这道题的精髓在于理解比较规则**：

### 1. 问题本质
不是比较数字本身的大小，而是比较它们**拼接后**的大小。

### 2. 关键洞察
对于任意两个数字字符串 a 和 b：
- 如果 `a + b > b + a`，那么 a 应该排在 b 前面
- 如果 `a + b < b + a`，那么 b 应该排在 a 前面

### 3. 数学证明
这种比较方式满足：
- **传递性**：如果 a≻b 且 b≻c，那么 a≻c
- **完整性**：对所有数字对都能做出比较
- **最优性**：能产生最大的拼接数字

### 4. 贪心思想
每次选择当前"最好"的排列方式，局部最优导致全局最优。

## 💡 更直观的理解

把数字想象成**扑克牌**：
- 每张牌是一个数字
- 我们要把这些牌排成一排，形成最大的数字
- 比较两张牌时，不是看单张牌的大小，而是看它们**左右排列**哪种方式得到的数字更大

```
牌：3, 30, 34, 5, 9

比较3和30：
  3在左：330
  30在左：303
  330 > 303，所以3应该排在30左边

最终排列：9, 5, 34, 3, 30 → 9534330
```

通过这道题，你将掌握自定义排序的核心技巧，这是解决许多复杂排序问题的关键！