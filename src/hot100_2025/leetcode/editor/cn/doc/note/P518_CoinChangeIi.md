# 零钱兑换 II - 完全背包问题

## 题目理解
给定不同面额的硬币和一个总金额，计算可以凑成总金额的硬币组合数。假设每种硬币的数量无限。

## 解题思路

### 总思路
使用动态规划，将问题转化为完全背包问题。定义`dp[i]`表示凑成金额`i`的组合数。

### 分步骤
1. 定义状态：`dp[i]`表示凑成金额`i`的组合数
2. 初始化：`dp[0] = 1`（凑成金额0只有一种方式：不选任何硬币）
3. 状态转移：对于每个硬币，更新所有大于等于该硬币面额的金额的组合数
4. 遍历顺序：先遍历硬币，再遍历金额，确保计算的是组合数而不是排列数

## 归类说明
- **主要分类**：动态规划、背包问题
- **算法技巧**：完全背包、组合数学
- **数据结构**：数组
- **相关题目**：零钱兑换、组合总和IV、分割等和子集

## Java代码实现

```java
class Solution {
    public int change(int amount, int[] coins) {
        // dp[i]表示凑成金额i的组合数
        int[] dp = new int[amount + 1];
        
        // 初始化：凑成金额0只有1种方式（不选任何硬币）
        dp[0] = 1;
        
        // 遍历每个硬币
        for (int coin : coins) {
            // 对于当前硬币，从coin开始遍历到amount
            // 这样可以确保金额j >= coin，避免负数索引
            for (int j = coin; j <= amount; j++) {
                // 状态转移：当前金额j的组合数 += 金额j-coin的组合数
                // 因为加上当前硬币coin就可以从金额j-coin达到金额j
                dp[j] += dp[j - coin];
            }
        }
        
        // 返回凑成总金额amount的组合数
        return dp[amount];
    }
}
```

## 关键点详细解析

### 1. 为什么`dp[0] = 1`？
- 凑成金额0只有一种方式：不选择任何硬币
- 这是动态规划的基准情况，所有状态都从这个基础推导出来

### 2. 遍历顺序的重要性
```java
for (int coin : coins) {           // 先遍历硬币
    for (int j = coin; j <= amount; j++) {  // 再遍历金额
        dp[j] += dp[j - coin];
    }
}
```
这种遍历顺序确保我们计算的是**组合数**而不是排列数。

**为什么？**
- 外层循环遍历硬币，内层循环遍历金额
- 这样对于每个金额，我们按固定的硬币顺序考虑
- 避免了`[1,2]`和`[2,1]`被算作两种不同的情况

### 3. 状态转移方程理解
`dp[j] += dp[j - coin]`

**含义**：
- 要凑成金额`j`，可以考虑使用当前硬币`coin`
- 如果使用一个`coin`硬币，那么剩下的金额就是`j - coin`
- 凑成`j - coin`的所有组合，每个组合加上一个`coin`硬币，就得到了凑成`j`的新组合

## 示例分析

以`amount = 5`, `coins = [1,2,5]`为例：

### 初始状态：
```
dp = [1, 0, 0, 0, 0, 0]
```

### 处理硬币1：
```java
coin = 1
j从1到5：
- j=1: dp[1] += dp[0] → dp[1] = 1
- j=2: dp[2] += dp[1] → dp[2] = 1  
- j=3: dp[3] += dp[2] → dp[3] = 1
- j=4: dp[4] += dp[3] → dp[4] = 1
- j=5: dp[5] += dp[4] → dp[5] = 1
```
此时`dp = [1, 1, 1, 1, 1, 1]`

### 处理硬币2：
```java
coin = 2
j从2到5：
- j=2: dp[2] += dp[0] → dp[2] = 1 + 1 = 2
- j=3: dp[3] += dp[1] → dp[3] = 1 + 1 = 2
- j=4: dp[4] += dp[2] → dp[4] = 1 + 2 = 3
- j=5: dp[5] += dp[3] → dp[5] = 1 + 2 = 3
```
此时`dp = [1, 1, 2, 2, 3, 3]`

### 处理硬币5：
```java
coin = 5  
j从5到5：
- j=5: dp[5] += dp[0] → dp[5] = 3 + 1 = 4
```
最终`dp = [1, 1, 2, 2, 3, 4]`

结果：4种组合方式：
1. 1+1+1+1+1
2. 1+1+1+2
3. 1+2+2
4. 5

## 不同遍历顺序的影响

### 正确的遍历顺序（组合数）：
```java
for (int coin : coins) {
    for (int j = coin; j <= amount; j++) {
        dp[j] += dp[j - coin];
    }
}
```
结果：计算的是组合数，`[1,2]`和`[2,1]`算作同一种

### 错误的遍历顺序（排列数）：
```java
for (int j = 1; j <= amount; j++) {
    for (int coin : coins) {
        if (j >= coin) {
            dp[j] += dp[j - coin];
        }
    }
}
```
结果：计算的是排列数，`[1,2]`和`[2,1]`算作两种不同的情况

## 学习建议

### 1. 理解完全背包问题
- 物品数量无限
- 求组合数（不是排列数）
- 状态定义：`dp[i]`表示容量为`i`的背包的方案数

### 2. 掌握遍历顺序的意义
- **先物品后容量**：计算组合数
- **先容量后物品**：计算排列数
- 理解为什么会产生这种差异

### 3. 相关题目练习
1. **零钱兑换**（LeetCode 322）
    - 求凑成金额的最少硬币数
    - 状态定义：`dp[i]`表示凑成金额`i`所需的最少硬币数

2. **组合总和IV**（LeetCode 377）
    - 求排列数而不是组合数
    - 需要改变遍历顺序

3. **分割等和子集**（LeetCode 416）
    - 0-1背包问题
    - 物品数量有限

### 4. 调试技巧
- 使用小例子手动计算dp数组
- 打印每次循环后的dp数组状态
- 对比不同遍历顺序的结果差异

### 5. 思维扩展
- 如果硬币数量有限（0-1背包）：需要改变状态定义和转移方程
- 如果要求具体方案：需要记录路径信息
- 如果硬币面值包含负数：需要特殊处理

通过这道题，你可以深入理解完全背包问题和组合计数的动态规划解法，这是动态规划中非常重要的基础题型！