# 300. 最长递增子序列

## 📝 解题思路（总分结构）

### 总思路
使用动态规划，定义 `dp[i]` 为以第 i 个元素结尾的最长递增子序列长度，通过遍历和状态转移来求解。

### 分步骤详解
1. **定义状态**：`dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列长度
2. **初始化**：每个位置的最短递增子序列至少包含自己，所以初始化为1
3. **状态转移**：对于每个 `i`，遍历所有 `j < i`，如果 `nums[i] > nums[j]`，则更新 `dp[i]`
4. **记录最大值**：在遍历过程中记录最大的 `dp[i]` 值
5. **返回结果**：返回记录的最大值

## 🏷️ 算法归类

**主要归类**：动态规划、序列问题  
**相关知识点**：状态定义、状态转移、数组遍历  
**难度级别**：中等  
**相似题型**：最长连续递增序列、最长递增子序列的个数、俄罗斯套娃信封问题

## 💻 Java代码实现

### 解法一：动态规划（O(n²)）

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        // 边界情况处理：如果数组为空或长度为0，直接返回0
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        // 步骤1：创建dp数组，dp[i]表示以nums[i]结尾的最长递增子序列长度
        int[] dp = new int[nums.length];
        
        // 步骤2：初始化dp数组，每个位置至少可以包含自己，所以初始化为1
        for (int i = 0; i < nums.length; i++) {
            dp[i] = 1;
        }
        
        // 步骤3：初始化最大长度为1（至少有一个元素）
        int maxLength = 1;
        
        // 步骤4：遍历数组，计算每个位置的最长递增子序列长度
        for (int i = 1; i < nums.length; i++) {
            // 遍历i之前的所有元素
            for (int j = 0; j < i; j++) {
                // 如果当前元素大于之前的某个元素，说明可以形成递增序列
                if (nums[i] > nums[j]) {
                    // 状态转移：dp[i] = max(dp[i], dp[j] + 1)
                    // 意思是：以i结尾的LIS长度，要么保持原值，要么是j位置的LIS长度+1
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            // 步骤5：更新全局最大长度
            maxLength = Math.max(maxLength, dp[i]);
        }
        
        // 步骤6：返回最长递增子序列的长度
        return maxLength;
    }
}
```

### 解法二：贪心 + 二分查找（O(n log n)）

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        // 边界情况处理
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        // 创建tail数组，tail[i]表示长度为i+1的递增子序列的最小末尾值
        int[] tail = new int[nums.length];
        // 初始化tail数组，第一个元素就是nums[0]
        tail[0] = nums[0];
        // 当前tail数组的长度（即当前找到的最长递增子序列长度）
        int len = 1;
        
        // 遍历数组中的每个元素
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > tail[len - 1]) {
                // 情况1：当前元素大于tail最后一个元素，直接追加
                tail[len] = nums[i];
                len++;
            } else {
                // 情况2：当前元素小于等于tail最后一个元素，二分查找替换位置
                int left = 0, right = len - 1;
                // 二分查找第一个大于等于nums[i]的位置
                while (left < right) {
                    int mid = left + (right - left) / 2;
                    if (tail[mid] < nums[i]) {
                        left = mid + 1;
                    } else {
                        right = mid;
                    }
                }
                // 用nums[i]替换找到的位置
                tail[left] = nums[i];
            }
        }
        
        // tail数组的长度就是最长递增子序列的长度
        return len;
    }
}
```

## 📚 学习建议

### 1. 理解动态规划的核心思想

**状态定义的理解**：
```java
// dp[i] 不是前i个元素的最长递增子序列长度
// 而是以第i个元素结尾的最长递增子序列长度
// 这个区别很重要！
```

**状态转移的理解**：
```java
// 对于每个i，我们要找所有j < i且nums[j] < nums[i]的位置
// 然后dp[i] = max(dp[i], dp[j] + 1)
// 这意味着：我们尝试将nums[i]接在nums[j]后面形成更长的递增序列
```

### 2. 算法过程可视化

**示例**：`nums = [10, 9, 2, 5, 3, 7, 101, 18]`

**动态规划解法过程**：
```
i=0: dp[0]=1 (序列:[10])
i=1: dp[1]=1 (序列:[9])，因为9<10，不能接在后面
i=2: dp[2]=1 (序列:[2])
i=3: 
  - j=0: 5>10? 否
  - j=1: 5>9? 否  
  - j=2: 5>2? 是 → dp[3]=max(1, dp[2]+1=2)=2 (序列:[2,5])
i=4:
  - j=0: 3>10? 否
  - j=1: 3>9? 否
  - j=2: 3>2? 是 → dp[4]=max(1, dp[2]+1=2)=2 (序列:[2,3])
  - j=3: 3>5? 否
i=5:
  - j=2: 7>2? 是 → dp[5]=max(1, dp[2]+1=2)=2
  - j=3: 7>5? 是 → dp[5]=max(2, dp[3]+1=3)=3 (序列:[2,5,7])
  - j=4: 7>3? 是 → dp[5]=max(3, dp[4]+1=3)=3
...
最终找到最长递增子序列长度为4 ([2,5,7,101] 或 [2,3,7,101])
```

### 3. 复杂度分析

**动态规划解法**：
- **时间复杂度**：O(n²) - 双重循环
- **空间复杂度**：O(n) - dp数组

**贪心+二分解法**：
- **时间复杂度**：O(n log n) - 遍历n个元素，每个元素二分查找
- **空间复杂度**：O(n) - tail数组

### 4. 两种解法对比

| 方面 | 动态规划 | 贪心+二分 |
|------|----------|-----------|
| **时间复杂度** | O(n²) | O(n log n) |
| **空间复杂度** | O(n) | O(n) |
| **理解难度** | 容易 | 中等 |
| **代码复杂度** | 简单 | 中等 |
| **适用场景** | 小规模数据 | 大规模数据 |

### 5. 学习路径建议

1. **先掌握动态规划解法**：思路直观，易于理解
2. **理解状态转移**：这是动态规划的核心
3. **学习贪心+二分**：理解为什么能用二分查找优化
4. **练习相似题目**：
    - 674. 最长连续递增序列
    - 673. 最长递增子序列的个数
    - 354. 俄罗斯套娃信封问题

### 6. 贪心+二分解法的深入理解

**tail数组的含义**：
```java
// tail[i] 表示长度为 i+1 的所有递增子序列中，最小的末尾值
// 这个数组是严格递增的，所以可以用二分查找
```

**为什么可以替换**：
```java
// 当我们用更小的值替换tail中的某个位置时
// 我们并没有改变当前的最长长度，但是为后面构造更长的序列创造了条件
// 比如：当前有 [2,5] 和 [2,3]，虽然长度都是2，但[2,3]的末尾更小
// 后面遇到4时，可以接在[2,3]后面形成[2,3,4]，但不能接在[2,5]后面
```

### 7. 调试技巧

**添加调试信息**：
```java
public int lengthOfLIS(int[] nums) {
    if (nums == null || nums.length == 0) return 0;
    
    int[] dp = new int[nums.length];
    Arrays.fill(dp, 1);
    int maxLength = 1;
    
    for (int i = 1; i < nums.length; i++) {
        System.out.println("处理 i=" + i + ", nums[i]=" + nums[i]);
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                int newLength = dp[j] + 1;
                System.out.println("  可以接在 j=" + j + " 后面，新长度=" + newLength);
                dp[i] = Math.max(dp[i], newLength);
            }
        }
        System.out.println("  dp[" + i + "] = " + dp[i]);
        maxLength = Math.max(maxLength, dp[i]);
    }
    
    return maxLength;
}
```

### 8. 常见错误避免

```java
// 错误：dp数组初始化为0
int[] dp = new int[nums.length];  // 应该初始化为1

// 错误：状态转移条件写反
if (nums[i] < nums[j]) {  // 应该是 nums[i] > nums[j]

// 错误：在贪心解法中二分查找条件错误
if (tail[mid] <= nums[i]) {  // 应该是 tail[mid] < nums[i]
```

### 9. 实际应用场景
- 股票价格的最长上涨期
- 生物信息学中的DNA序列分析
- 游戏中的最长连胜记录
- 数据分析中的趋势分析

## 🎯 核心思想总结

**动态规划解法的精髓**：
1. **状态定义**：明确 `dp[i]` 的含义
2. **状态转移**：通过比较和选择来更新状态
3. **初始化**：合理的初始值是正确计算的基础
4. **结果提取**：从dp数组中找出最终答案

**贪心+二分解法的优势**：
1. **维护最小末尾**：让后续数字有更多机会形成更长序列
2. **二分优化**：利用有序性将查找时间从O(n)降到O(log n)
3. **空间换时间**：通过额外数组存储中间结果

对于初学者，建议先彻底理解动态规划解法，再学习贪心+二分解法。动态规划是基础，贪心+二分是优化，两者都掌握才能应对不同场景的需求。

通过这道题，你将深入理解动态规划在序列问题中的应用，这是解决许多复杂问题的基础！