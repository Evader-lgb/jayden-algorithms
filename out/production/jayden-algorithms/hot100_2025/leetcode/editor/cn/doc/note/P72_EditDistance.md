# 72. 编辑距离 - 深入理解

## 📝 解题思路（总分结构）

### 总思路
使用动态规划，`dp[i][j]` 表示将 `word1` 的前 `i` 个字符转换为 `word2` 的前 `j` 个字符所需的最小操作次数。

### 分步骤详解
1. **定义状态**：`dp[i][j]` 表示转换前 i 个字符到前 j 个字符的最小操作数
2. **初始化边界**：处理空字符串的情况
3. **状态转移**：根据字符是否相等选择不同操作
4. **返回结果**：`dp[m][n]` 即为答案

## 🏷️ 算法归类

**主要归类**：动态规划、字符串处理  
**相关知识点**：状态转移、边界初始化  
**难度级别**：困难

## 💻 Java代码实现（带详细注释）

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        
        // 创建DP表，dp[i][j]表示word1前i个字符转成word2前j个字符的最小操作数
        int[][] dp = new int[m + 1][n + 1];
        
        // 初始化：word1为空字符串时，只能通过插入操作
        for (int j = 0; j <= n; j++) {
            dp[0][j] = j;  // 插入j个字符
        }
        
        // 初始化：word2为空字符串时，只能通过删除操作  
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i;  // 删除i个字符
        }
        
        // 填充DP表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    // 字符相等，不需要操作，直接继承左上角的值
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    // 字符不相等，考虑三种操作，取最小值+1
                    dp[i][j] = Math.min(
                        Math.min(
                            dp[i - 1][j],     // 删除word1的第i个字符
                            dp[i][j - 1]      // 在word1插入word2的第j个字符
                        ),
                        dp[i - 1][j - 1]      // 替换word1的第i个字符为word2的第j个字符
                    ) + 1;  // 无论哪种操作，都需要1步
                }
            }
        }
        
        return dp[m][n];
    }
}
```

## 🔍 深入理解状态转移方程

### 三种操作的直观理解

#### 1. 删除操作：`dp[i-1][j] + 1`
**场景**：`word1 = "abc"` → `word2 = "ac"`
```
当前比较：'c' vs 'c' (相等)
但之前：'ab' → 'a' 需要操作
删除'b'：'abc' → 'ac'
```
**理解**：放弃 `word1` 的当前字符，问题规模变为 `前i-1个字符 → 前j个字符`

#### 2. 插入操作：`dp[i][j-1] + 1`
**场景**：`word1 = "ac"` → `word2 = "abc"`
```
当前：'ac' → 'ab' 需要操作
插入'b'：'ac' → 'abc'
```
**理解**：添加 `word2` 的当前字符，问题规模变为 `前i个字符 → 前j-1个字符`

#### 3. 替换操作：`dp[i-1][j-1] + 1`
**场景**：`word1 = "abc"` → `word2 = "adc"`
```
当前：'c' vs 'c' (相等)
但之前：'ab' → 'ad' 需要操作  
替换'b'为'd'：'abc' → 'adc'
```
**理解**：改变 `word1` 的当前字符，问题规模变为 `前i-1个字符 → 前j-1个字符`

## 📊 具体例子演示

### 例子：`"horse"` → `"ros"`

**DP表填充过程**：
```
初始：
     r  o  s
  0  1  2  3
h 1
o 2
r 3  
s 4
e 5

最终：
     r  o  s
  0  1  2  3
h 1  1  2  3
o 2  2  1  2
r 3  2  2  2
s 4  3  3  2
e 5  4  4  3
```

**关键步骤分析**：

1. `dp[1][1]`：'h' vs 'r' → 不相等
    - 删除：`dp[0][1]=1 + 1 = 2`
    - 插入：`dp[1][0]=1 + 1 = 2`
    - 替换：`dp[0][0]=0 + 1 = 1`
    - 选择替换 → `dp[1][1] = 1`

2. `dp[2][2]`：'ho' vs 'ro' → 最后字符'o'相等
    - 直接继承 `dp[1][1] = 1`

3. `dp[5][3]`：最终结果 = 3

## 🎯 为什么这样设计状态转移？

### 1. 完备性覆盖
三种操作覆盖了所有可能的编辑方式：
- **删除**：源字符串太长
- **插入**：源字符串太短
- **替换**：字符不匹配

### 2. 最优子结构
每个决策都基于子问题的最优解：
- 我们不知道哪种操作最好
- 但可以计算每种操作的成本
- 选择成本最低的操作

### 3. 无后效性
当前决策只依赖于已解决的子问题，不影响后续决策。

## 💡 生活化类比

### 类比1：拼图游戏
- **删除**：去掉多余的拼图块
- **插入**：添加缺失的拼图块
- **替换**：更换错误的拼图块

### 类比2：编辑文档
- **删除**：删除多余文字
- **插入**：添加遗漏文字
- **替换**：修改错误文字

## 🔄 调试技巧

**添加详细日志**：
```java
public int minDistance(String word1, String word2) {
    int m = word1.length(), n = word2.length();
    int[][] dp = new int[m+1][n+1];
    
    for (int j = 0; j <= n; j++) dp[0][j] = j;
    for (int i = 0; i <= m; i++) dp[i][0] = i;
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            char c1 = word1.charAt(i-1);
            char c2 = word2.charAt(j-1);
            
            System.out.printf("比较: word1[%d]='%c' vs word2[%d]='%c'", 
                i-1, c1, j-1, c2);
            
            if (c1 == c2) {
                dp[i][j] = dp[i-1][j-1];
                System.out.printf(" → 相等，继承dp[%d][%d]=%d\n", i-1, j-1, dp[i][j]);
            } else {
                int delete = dp[i-1][j] + 1;
                int insert = dp[i][j-1] + 1;
                int replace = dp[i-1][j-1] + 1;
                
                dp[i][j] = Math.min(Math.min(delete, insert), replace);
                System.out.printf(" → 不相等，删除=%d, 插入=%d, 替换=%d, 选择=%d\n", 
                    delete, insert, replace, dp[i][j]);
            }
        }
    }
    
    return dp[m][n];
}
```

## 🏆 核心思想总结

**编辑距离的精髓**：

1. **状态设计**：`dp[i][j]` 表示子问题的最优解
2. **边界处理**：正确处理空字符串的特殊情况
3. **状态转移**：通过比较选择最优操作
4. **最优子结构**：全局最优包含局部最优

**关键洞察**：
- 当字符匹配时，不需要额外操作
- 当字符不匹配时，选择成本最低的操作
- 整个DP表体现了"逐步构建最优解"的思想

通过这个详细的解释，你现在应该对编辑距离问题有了更深入的理解。这个算法在拼写检查、DNA序列比对等领域有广泛应用，是动态规划的经典案例！