# 回溯算法详细过程解析 - 以 [1,2,3] 为例

让我用更详细的方式来解释这个递归过程。我们把整个过程想象成一棵**决策树**，每个层级代表我们要选择第几个数字。

## 🌳 决策树可视化

```
开始: path = [], used = [false, false, false]
│
├── 第一层：选择1 (path = [1], used = [true, false, false])
│   │
│   ├── 第二层：选择2 (path = [1,2], used = [true, true, false])
│   │   │
│   │   └── 第三层：选择3 (path = [1,2,3], used = [true, true, true])
│   │       → 找到排列 [1,2,3]，保存结果
│   │       → 撤销选择3 (path = [1,2], used = [true, true, false])
│   │       → 第三层循环结束，回到第二层
│   │
│   ├── 第二层：撤销选择2 (path = [1], used = [true, false, false])
│   │
│   ├── 第二层：选择3 (path = [1,3], used = [true, false, true])
│   │   │
│   │   └── 第三层：选择2 (path = [1,3,2], used = [true, true, true])
│   │       → 找到排列 [1,3,2]，保存结果
│   │       → 撤销选择2 (path = [1,3], used = [true, false, true])
│   │       → 第三层循环结束，回到第二层
│   │
│   └── 第二层：撤销选择3 (path = [1], used = [true, false, false])
│       → 第二层循环结束，回到第一层
│
├── 第一层：撤销选择1 (path = [], used = [false, false, false])
│
├── 第一层：选择2 (path = [2], used = [false, true, false])
│   │
│   ├── 第二层：选择1 (path = [2,1], used = [true, true, false])
│   │   │
│   │   └── 第三层：选择3 (path = [2,1,3], used = [true, true, true])
│   │       → 找到排列 [2,1,3]，保存结果
│   │       → 撤销选择3 (path = [2,1], used = [true, true, false])
│   │       → 第三层循环结束，回到第二层
│   │
│   ├── 第二层：撤销选择1 (path = [2], used = [false, true, false])
│   │
│   ├── 第二层：选择3 (path = [2,3], used = [false, true, true])
│   │   │
│   │   └── 第三层：选择1 (path = [2,3,1], used = [true, true, true])
│   │       → 找到排列 [2,3,1]，保存结果
│   │       → 撤销选择1 (path = [2,3], used = [false, true, true])
│   │       → 第三层循环结束，回到第二层
│   │
│   └── 第二层：撤销选择3 (path = [2], used = [false, true, false])
│       → 第二层循环结束，回到第一层
│
└── ... 继续选择3的流程
```

## 🔍 逐层详细解释

### 什么是"层"？

- **第一层**：选择排列的第一个数字
- **第二层**：选择排列的第二个数字
- **第三层**：选择排列的第三个数字

### 详细执行流程

让我们一步步跟踪代码的执行：

#### 步骤1：进入第一层循环
```text
// i=0: 选择数字1
path.add(1);        // path = [1]
used[0] = true;     // used = [true, false, false]
```

#### 步骤2：进入第二层循环（在第一层选择1的基础上）
```text
// i=0: 数字1已使用，跳过
// i=1: 选择数字2
path.add(2);        // path = [1,2]
used[1] = true;     // used = [true, true, false]
```

#### 步骤3：进入第三层循环（在前两层选择1,2的基础上）
```text
// i=0: 数字1已使用，跳过
// i=1: 数字2已使用，跳过  
// i=2: 选择数字3
path.add(3);        // path = [1,2,3]
used[2] = true;     // used = [true, true, true]

// 此时 path.size() == 3，满足终止条件
result.add(new ArrayList<>(path));  // 保存 [1,2,3]
```

#### 步骤4：开始回溯（撤销选择）
```text
// 第三层循环结束，回溯到第二层
path.remove(2);     // 移除3，path = [1,2]  
used[2] = false;    // used = [true, true, false]

// 第二层继续循环：i=2，选择数字3
path.add(3);        // path = [1,3]
used[2] = true;     // used = [true, false, true]
```

#### 步骤5：再次进入第三层（选择1,3的基础上）
```text
// i=0: 数字1已使用，跳过
// i=1: 选择数字2
path.add(2);        // path = [1,3,2]
used[1] = true;     // used = [true, true, true]

// 保存结果 [1,3,2]
result.add(new ArrayList<>(path));
```

## 🎯 关键概念解释

### 1. "层"的含义
- **不是物理层级**，而是递归调用的深度
- 每深入一层递归，就多选择一个数字
- 当递归深度 = 数组长度时，得到一个完整排列

### 2. 回溯的本质
回溯就是"尝试-撤销"的过程：
```text
// 尝试选择
path.add(num);
used[i] = true;

// 递归探索
backtrack(...);

// 撤销选择（回溯）
path.remove(last);
used[i] = false;
```

### 3. 为什么需要撤销？
因为我们要探索**所有可能性**：
- 选择了 [1,2] 后，要尝试 [1,3]
- 所以必须撤销2的选择，才能选择3

## 💡 更直观的理解方式

把回溯过程想象成**走迷宫**：

1. **选择路径**：走到一个岔路口，选择一条路
2. **探索到底**：一直走到尽头（找到解或死路）
3. **退回岔路口**：回到上一个选择点
4. **尝试另一条路**：选择不同的方向

```
迷宫比喻：
开始 → 岔路口1(选择1/2/3)
  选择1 → 岔路口2(选择2/3)
    选择2 → 终点 [1,2,3] ✓
    退回岔路口2
    选择3 → 终点 [1,3,2] ✓
  退回岔路口1
  选择2 → 岔路口2(选择1/3)
    ...
```

## 🔄 完整的调用栈模拟

让我们用调用栈的角度来看：

```
调用栈深度0: backtrack() - 第一层循环开始
│
├─ 调用栈深度1: backtrack() - 选择1，进入第二层循环
│  │
│  ├─ 调用栈深度2: backtrack() - 选择2，进入第三层循环  
│  │  │
│  │  ├─ 调用栈深度3: backtrack() - 选择3，保存[1,2,3]，返回
│  │  │
│  │  └─ 回到深度2：撤销3，选择3（跳过），循环结束，返回
│  │
│  ├─ 回到深度1：撤销2，选择3，进入新的深度2
│  │  │
│  │  └─ 调用栈深度2: backtrack() - 选择3，进入第三层循环
│  │     │
│  │     └─ 调用栈深度3: backtrack() - 选择2，保存[1,3,2]，返回
│  │
│  └─ 回到深度1：撤销3，循环结束，返回
│
└─ 回到深度0：撤销1，选择2，进入新的深度1...
```

## 🏆 总结

**"层"的本质**：
- 就是递归的深度
- 每深一层，多做一个选择
- 当深度 = 数组长度时，完成一个排列

**回溯的精髓**：
- 尝试所有可能性
- 通过"选择-递归-撤销"来探索不同路径
- 像深度优先搜索一样遍历决策树

现在你应该能理解为什么会有"第一层"、"第二层"的说法了。它们代表我们在决策树中的不同深度，每个深度对应选择排列中的第几个数字。

这个过程确实需要一些时间来理解，但一旦掌握了，你就能解决很多类似的回溯问题！