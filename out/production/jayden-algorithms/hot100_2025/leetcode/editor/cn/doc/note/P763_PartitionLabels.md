# 划分字母区间

## 题目理解
给定一个字符串 `s`，我们需要将字符串划分为尽可能多的片段，使得同一字母最多出现在一个片段中。返回每个片段的长度列表。

## 解题思路

### 总思路
使用贪心算法，通过记录每个字符最后出现的位置，然后遍历字符串来动态确定每个片段的结束位置。

### 分步骤
1. **记录每个字符的最后出现位置**：使用数组记录每个字母在字符串中最后出现的位置
2. **遍历字符串确定片段**：维护当前片段的开始和结束位置，遍历时更新结束位置为当前字符的最后出现位置
3. **划分片段**：当遍历到当前片段的结束位置时，记录片段长度并开始新的片段

## 归类说明
- **主要分类**：贪心算法、字符串处理
- **算法技巧**：双指针、位置记录
- **数据结构**：数组、哈希表
- **相关题目**：合并区间、无重叠区间、根据字符出现频率排序

## Java代码实现

```java
import java.util.*;

class Solution {
    public List<Integer> partitionLabels(String s) {
        List<Integer> result = new ArrayList<>();
        
        // 1. 记录每个字符最后出现的位置
        int[] lastOccurrence = new int[26]; // 26个小写字母
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            lastOccurrence[c - 'a'] = i; // 更新字符c的最后出现位置
        }
        
        // 2. 使用双指针划分片段
        int start = 0; // 当前片段的起始位置
        int end = 0;   // 当前片段的结束位置
        
        for (int i = 0; i < s.length(); i++) {
            char currentChar = s.charAt(i);
            // 更新当前片段的结束位置为当前字符的最后出现位置
            end = Math.max(end, lastOccurrence[currentChar - 'a']);
            
            // 如果当前位置等于当前片段的结束位置
            // 说明当前片段可以结束了
            if (i == end) {
                // 计算当前片段的长度并添加到结果
                result.add(end - start + 1);
                // 更新下一个片段的起始位置
                start = i + 1;
            }
        }
        
        return result;
    }
}
```

## 关键点详细解析

### 1. 记录最后出现位置
```java
int[] lastOccurrence = new int[26];
for (int i = 0; i < s.length(); i++) {
    char c = s.charAt(i);
    lastOccurrence[c - 'a'] = i;
}
```
- 创建长度为26的数组，对应26个小写字母
- 遍历字符串，不断更新每个字符的最后出现位置
- 例如：字符串 `"ababcbac"` 中，字符 `'a'` 的最后位置是7

### 2. 双指针划分片段
```java
for (int i = 0; i < s.length(); i++) {
    char currentChar = s.charAt(i);
    end = Math.max(end, lastOccurrence[currentChar - 'a']);
    
    if (i == end) {
        result.add(end - start + 1);
        start = i + 1;
    }
}
```
- `start` 和 `end` 定义当前片段的边界
- 遍历时，对于每个字符，更新 `end` 为当前字符的最后出现位置
- 当 `i == end` 时，说明当前片段包含了所有需要包含的字符

## 示例分析

### 示例：`s = "ababcbacadefegdehijhklij"`

**步骤1：记录最后出现位置**
```
a: 8, b: 5, c: 7, d: 14, e: 15, f: 11, g: 13, h: 19, i: 22, j: 23, k: 20, l: 21
```

**步骤2：划分片段**
- 从位置0开始：
    - 字符'a'，最后位置8 → end = 8
    - 字符'b'，最后位置5 → end = max(8,5) = 8
    - 字符'a'，最后位置8 → end = 8
    - ...直到位置8
    - 在位置8，i == end，第一个片段：[0,8]，长度9

- 从位置9开始：
    - 字符'd'，最后位置14 → end = 14
    - 字符'e'，最后位置15 → end = max(14,15) = 15
    - 字符'f'，最后位置11 → end = 15
    - ...直到位置15
    - 在位置15，i == end，第二个片段：[9,15]，长度7

- 从位置16开始：
    - 字符'h'，最后位置19 → end = 19
    - 字符'i'，最后位置22 → end = max(19,22) = 22
    - 字符'j'，最后位置23 → end = max(22,23) = 23
    - ...直到位置23
    - 在位置23，i == end，第三个片段：[16,23]，长度8

**最终结果**：`[9,7,8]`

## 学习建议

### 1. 理解贪心思想
- 每个片段尽可能小，但必须包含所有相同字符
- 局部最优选择导致全局最优解

### 2. 掌握双指针技巧
- `start` 指针标记片段开始
- `end` 指针动态更新片段结束
- 当两个指针相遇时完成一个片段

### 3. 相关题目练习
1. **合并区间**（LeetCode 56）
    - 类似的区间处理思想
    - 需要排序和合并重叠区间

2. **无重叠区间**（LeetCode 435）
    - 选择不重叠区间的最大数量
    - 类似的贪心策略

3. **根据字符出现频率排序**（LeetCode 451）
    - 基于字符频率的字符串处理

### 4. 调试技巧
- 使用小字符串手动模拟过程
- 打印每个步骤的start和end值
- 画图理解字符位置关系

### 5. 复杂度分析
- **时间复杂度**：O(n)，两次线性遍历
- **空间复杂度**：O(1)，使用固定大小的数组（26个字母）

### 6. 边界情况考虑
- 空字符串：返回空列表
- 所有字符都相同：返回包含整个字符串长度的列表
- 没有重复字符：每个字符一个片段

通过这道题，你可以深入理解贪心算法和双指针技巧在字符串处理中的应用！