# 5. 最长回文子串

## 📝 解题思路（总分结构）

### 总思路
使用中心扩展法，遍历字符串的每个字符，以每个字符（或每两个字符）为中心向两边扩展，寻找最长的回文子串。

### 分步骤详解
1. **边界情况处理**：处理空串或单字符字符串
2. **初始化变量**：记录最长回文的起始位置和长度
3. **中心扩展**：对每个字符进行两种中心扩展
    - 以单个字符为中心（奇数长度回文）
    - 以两个字符为中心（偶数长度回文）
4. **更新最长回文**：比较并记录找到的最长回文
5. **返回结果**：根据起始位置和长度返回子串

## 🏷️ 算法归类

**主要归类**：字符串处理、中心扩展、双指针  
**相关知识点**：回文串、字符串遍历、边界扩展  
**难度级别**：中等  
**相似题型**：回文子串、最长回文子序列、验证回文串

## 💻 Java代码实现

```java
class Solution {
    public String longestPalindrome(String s) {
        // 边界情况处理：如果字符串为空或长度为0，直接返回空字符串
        if (s == null || s.length() < 1) {
            return "";
        }
        
        // 初始化变量，记录最长回文子串的起始位置和结束位置
        int start = 0;  // 最长回文子串的起始索引
        int end = 0;    // 最长回文子串的结束索引
        
        // 遍历字符串中的每个字符，作为中心点进行扩展
        for (int i = 0; i < s.length(); i++) {
            // 情况1：以当前字符为中心，向两边扩展（奇数长度回文）
            int len1 = expandAroundCenter(s, i, i);
            
            // 情况2：以当前字符和下一个字符为中心，向两边扩展（偶数长度回文）
            int len2 = expandAroundCenter(s, i, i + 1);
            
            // 取两种扩展方式中的较大长度
            int len = Math.max(len1, len2);
            
            // 如果当前找到的回文长度大于已知最长回文长度
            if (len > end - start) {
                // 更新最长回文子串的起始和结束位置
                // 起始位置 = 当前中心 - (长度-1)/2
                start = i - (len - 1) / 2;
                // 结束位置 = 当前中心 + 长度/2
                end = i + len / 2;
            }
        }
        
        // 根据起始位置和结束位置返回最长回文子串
        // substring方法截取从start到end+1的子串
        return s.substring(start, end + 1);
    }
    
    /**
     * 中心扩展函数：从给定的左右中心向两边扩展，寻找回文子串
     * @param s 输入字符串
     * @param left 左中心位置
     * @param right 右中心位置
     * @return 回文子串的长度
     */
    private int expandAroundCenter(String s, int left, int right) {
        // 当左右指针在有效范围内且指向的字符相等时，继续向两边扩展
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            // 向左移动左指针
            left--;
            // 向右移动右指针
            right++;
        }
        
        // 返回回文子串的长度
        // 注意：循环结束时，left和right指向的是不满足回文条件的位置
        // 所以回文子串的实际长度是 (right - left - 1)
        return right - left - 1;
    }
}
```

## 📚 学习建议

### 1. 理解中心扩展法的核心思想

**为什么需要两种中心扩展？**
```java
// 奇数长度回文： "aba" - 中心是单个字符 'b'
int len1 = expandAroundCenter(s, i, i);

// 偶数长度回文： "abba" - 中心是两个字符 'b' 和 'b'
int len2 = expandAroundCenter(s, i, i + 1);
```

**扩展过程的可视化：**
```
字符串: "babad"

以索引1为中心（字符'a'）：
  初始: left=1, right=1 → "a"
  扩展: left=0, right=2 → "bab" ✓
  再扩展: left=-1, right=3 → 停止
  得到回文: "bab"，长度=3

以索引2为中心（字符'b'）：
  初始: left=2, right=3 → "ba" ✗
  得到回文: "b"，长度=1
```

### 2. 掌握关键计算逻辑

**起始和结束位置的计算：**
```text
// 对于奇数长度回文："bab" (i=1, len=3)
start = 1 - (3-1)/2 = 1 - 1 = 0
end = 1 + 3/2 = 1 + 1 = 2
// 子串: s[0:2] = "bab"

// 对于偶数长度回文："abba" (i=1, len=4)  
start = 1 - (4-1)/2 = 1 - 1 = 0
end = 1 + 4/2 = 1 + 2 = 3
// 子串: s[0:3] = "abba"
```

### 3. 复杂度分析
- **时间复杂度**：O(n²) - 每个字符最多扩展O(n)次
- **空间复杂度**：O(1) - 只使用了常数级别的额外空间

### 4. 与其他解法对比

**动态规划解法**：
```java
// 使用二维dp数组，dp[i][j]表示s[i..j]是否为回文
// 时间复杂度O(n²)，空间复杂度O(n²)
boolean[][] dp = new boolean[n][n];
```

**Manacher算法**：
```java
// 专门用于寻找最长回文子串的算法
// 时间复杂度O(n)，但实现较复杂
```

### 5. 学习路径建议

1. **先掌握中心扩展法**：思路直观，代码简洁
2. **理解两种中心类型**：单字符中心和双字符中心
3. **练习相似题目**：
    - 647. 回文子串
    - 516. 最长回文子序列
    - 125. 验证回文串
4. **手动模拟过程**：用具体例子跟踪扩展过程

### 6. 边界情况处理

**代码自动处理的边界情况：**
- 空字符串
- 单字符字符串
- 全相同字符的字符串
- 无回文子串的情况

### 7. 优化技巧

**提前终止优化**：
```text
// 如果剩余可能找到的回文不可能超过当前最大值，可以提前终止
if ((s.length() - i) * 2 <= maxLength) {
    break;
}
```

### 8. 常见错误避免

```text
// 错误：忘记处理偶数长度回文
// 只使用单中心扩展会错过 "abba" 这样的回文

// 错误：边界条件处理不当
while (left > 0 && right < s.length() - 1 && ...) 
// 应该使用 >=0 和 < s.length()

// 错误：长度计算错误
return right - left + 1;  // 应该是 right - left - 1
```

### 9. 调试技巧

**添加调试输出**：
```java
private int expandAroundCenter(String s, int left, int right) {
    int L = left, R = right;
    while (L >= 0 && R < s.length() && s.charAt(L) == s.charAt(R)) {
        System.out.println("扩展: " + s.substring(L, R + 1));
        L--;
        R++;
    }
    int length = R - L - 1;
    System.out.println("中心: (" + left + "," + right + "), 长度: " + length);
    return length;
}
```

### 10. 实际应用场景
- DNA序列分析
- 文本处理中的模式匹配
- 数据压缩算法
- 网络安全中的恶意代码检测

通过这道题，你将掌握字符串处理中的中心扩展技巧，这是解决回文相关问题的核心方法。中心扩展法的思想在很多字符串问题中都有应用，值得深入理解和掌握！